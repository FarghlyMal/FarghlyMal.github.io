---
title: "Process Hollowing"
classes: wide
header:
  teaser: https://kapitanhack.pl/wp-content/uploads/2019/03/Malware-Powload.jpg
ribbon: DodgerBlue
description: "Exploring process Hollowing in the view of Anati-debugging"
categories:
  - Malware Analysis
toc: true
---
**Hello brothers**, today I am going to explain anti reversing technique which also is a technique of process injection before digging deep into the details of this method, first we need to explain what process hollowing is, after that, I will explain with code snippets and APIs

process hollowing relies on creating a process, but only in a suspended mode, which makes it seem like it has also been choked with no window to make the user feel nothing; and then it unmaps or cuts the relations of the program with memory that make program code is not in memory (Unmaping) after that it allocates space in memory of the program to write the malicious code into it and then make the EIP points to new Code section of the Malicious code using APIs which we will explain below  
,this GIF Explains what it looks like in a clear and simple way

![](https://miro.medium.com/v2/resize:fit:823/1*N5AGFpFx32mNhlMcpTBTdg.gif)

This image belongs to  [**https://www.elastic.co/**](https://www.elastic.co/)

moving to our lady IDA, which makes reversing easy something  
I have a simple code whose only mission is process hollowing, I am going to explain line-by-line assembly code I hope it looks like what I expect

# first

it initiates a cookie which is used to avoid stack overflow vulnerability, then it fills the structure of Statup_info with zeros

— the **startup_info** is a data structure used to save information about the startup process (exe name, commands and arguments) then it also zeros out the context

![](https://miro.medium.com/v2/resize:fit:584/1*PLcJHEeYA_8azZUYOBdktA.png)<center><font size="3"> <u>Figure</u>(1): <u>zero out startup_info</u> </font></center> 


as we explained before the program is going to lunch a process in suspended mode and our Target process here is **svchost.exe**, the flag **dwCreationFlags = 4** which indicates that is a suspended process which is the core of process hollowing, and it uses [**CreateProcessA**](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa)() to do that

![](https://miro.medium.com/v2/resize:fit:875/1*5RIWRck_f1e-vm_xeX0ElA.png)<center><font size="3"> <u>Figure</u>(1): <u>Create svchost.exe in suspended mode</u> </font></center> 


after that, it saves the information of the thread before the UnMaping process to avoid crashing, that’s done by Calling [**GetThreadContext**(](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext)) API

![](https://miro.medium.com/v2/resize:fit:634/1*C0nDc_odqJlrIguLU0AdTg.png)<center><font size="3"> <u>Figure</u>(1): <u>Save thread information</u> </font></center> 


After that, it resolves [**ZwUnmapViewOfSection**()](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwunmapviewofsection) API using dynamic linking via [**GetModuleHandle**](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea)(ntdll.dll) and [**GetProcAddress**](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress)() and save the address of the API in Eax

![](https://miro.medium.com/v2/resize:fit:633/1*VAC5a3wStDn1cuj-WdEcqg.png)<center><font size="3"> <u>Figure</u>(1): <u>zDynamic resolving</u> </font></center> 


after resolving, it calls [**ZwUnmapViewOfSection**](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-zwunmapviewofsection)() which unmaps the code section that’s addressed is 0x400000h(Base address)

![](https://miro.medium.com/v2/resize:fit:650/1*dVsuxsAyea422N29i5Qd8A.png)

then the swapping process comes and that’s done through many steps first of it is allocating a memory space in the targeted function using [**VirtualAllocEx**](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex)() which can allocate a space in another process’s memory and give the svchost.exe handle as the first argument and this API retrieves the address of the allocated memory in EAX register, the argument **(flprotect=0x40h → PAGE_EXECUTE_READWRITE)** and the argument **(flAllocationType = 0x3000h →MEM_COMMIT || MEM_RESERVE )**

![](https://miro.medium.com/v2/resize:fit:708/1*7ID_ivDc7CdtBKBWQSImpQ.png)<center><font size="3"> <u>Figure</u>(1): <u>Memory allocation
</u> </font></center> 


all thing is ready to inject, we just need to inject data and the program does this by calling [**WriteProcessMemory**](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)() API and passing process handle and base address as arguments  
but the important push here is **(lpBuffer → this argument is a pointer to the code which is going to be injected)** in our case we only need to inject this Byte (0xcc = int3 → a system breakpoint) → the mal devs put their shell code here

![](https://miro.medium.com/v2/resize:fit:705/1*jJ98jewH4QOqAB_L6Isppw.png)
<center><font size="3"> <u>Figure</u>(1): <u>Injecting code</u> </font></center> 

code is injected and all thing is done except 2 steps which are very important too

### 1- fill the thread context with data needed to avoid crashing and that’s done by [**SetThreadContext**](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext)() API and fill it with the following  
	1.0 -BaseAddress which saved in EAX Register  
	1.1 -ContextFlags and here we will explain something  
the value **0x10002h** is a combination of **Context_Full(0001h)** and **Context_debug_register(2000h)**  
— the **Context_full** flag specifies that the context contains all the standard Registers

—  the **Context_debug_Register** flag specifies that the context structure contains Debug Registers DR0-DR7

### 2-do u remember that we create the process in a suspended state and then we unmap the code, and then we write another code, so we need now to make all things look normal and run the process in a normal state with our payload, and we will do this by using [**ResumeThread**](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread)() API which is used to resume a suspended thread

![](https://miro.medium.com/v2/resize:fit:648/1*z0GRP1mTqF6L-dt1sxGBmw.png)
<center><font size="3"> <u>Figure</u>(1): <u>z
Complete execution</u> </font></center> 

I hope I have explained enough. This is what I can do. If you see any modifications or mistakes, do not hesitate to tell me, thank you.
