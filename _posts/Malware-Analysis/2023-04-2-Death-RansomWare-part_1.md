---
title: "Death Ransomware Analysis_part1"
classes: wide
header:
  teaser: https://miro.medium.com/v2/resize:fit:1100/format:webp/1*LsLIUxvY0wj4bNMZo-ajsA.jpeg
ribbon: DodgerBlue
description: "First part for Analyzing Death Ransomware"
categories:
  - 
toc: true
---
# Introduction
Hello Cyber Geeks, today I am going to explain how Death Ransom behavior is done and how the encryption method happens, and how to detect it using **Yara and IOCs**

# overview :

Discovered by [GrujaRS](https://twitter.com/GrujaRS), DeathRansom is malicious software, classified as ransomware. In general, systems infected with malware of this type have their data encrypted. The cybercriminals behind the encryption then demand a ransom to be paid for decryption tools/software, there are 2 versions of Death Ransom, and one of them does not encrypt your Files it just appends “**.wctc**” extension to the Fils, for example,

**lol.jpg → lol.jpg.wctc ,** but the data is the same data with no encryption, let’s dig into the code and properties of the File, the other one encrypts it without appending any extensions.

**sha 1: 65B5F8CC7B0B6315FE934578F9CAD4FAF7DA41F2**

# First Stage :

the malware comes in a packed formal and many noisy **mangled symbols** generated by the C++ Compiler, so let’s try to unpack it using some methods and techniques

![](https://miro.medium.com/v2/resize:fit:875/1*hG0_3EfJKT8pV9w8RdTD9Q.png)

so there are some suspicious calls that the malware uses to allocate memory and then unpack the code in this memory like

> [_VirtualAlloc()_](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)
> 
> [_VirtualProtect()_](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect)
> 
> [_GlobalAlloc()_](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalalloc)
> 
> [_LocalAlloc()_](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localalloc)

we need to search for these APIs in The imports section in the Malware and trace these calls and look at what happens in the allocated spaces may we get the 2Stage or another shell Code,

I see a suspicious call to [**LocalAlloc()**](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-localalloc)  which is used to allocate a local memory space and the **uBytes** Globale Variable is used in another place which is a big indicator of the unpacking process

![](https://miro.medium.com/v2/resize:fit:875/1*3ec0QdURwBa2Qsq4lY58hQ.png)

and we see another call to [**GetProcAddress()**](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) which is used to get the address of an API, so we will complete the analysis using the debugger and appending some breakpoints in the APIs mentioned above

![](https://miro.medium.com/v2/resize:fit:854/1*hH0z62uI_4H5FbpYaF8r9g.png)

here is our debugger hitting the first breakpoint in calling LocalAlloc, I will dump the address of the memory allocated and complete running our debugger

![](https://miro.medium.com/v2/resize:fit:875/1*KS0LSMFzYpPEhg9rHKn0bg.png)

we hit another call to GetPorcaddress resolving the address of VirualProtect which is used in changing the protection of a memory space

![](https://miro.medium.com/v2/resize:fit:875/1*TzeNcgMMczc9p5Ypkwgt5Q.png)

and if we take another look at the memory allocated we will see that it’s filled with some bytes which the debugger will transfer the execution to this ShellCode

![](https://miro.medium.com/v2/resize:fit:875/1*Xi1XlUJ-MWNRQpVMmccTbQ.png)

and here is how the program starts executing the shellcode

![](https://miro.medium.com/v2/resize:fit:875/1*shbTP5SdsMcQG2U9l8_jZQ.png)

we will set a memory breakpoint on the execution of this memory, and here is the hit of the breakpoint

![](https://miro.medium.com/v2/resize:fit:875/1*rl11dGnWg4c8p_axJhD6ZQ.png)

so we will complete the breakpoint set before, and we will hit a call to virtualAlloc() API which is used in allocating a memory space

![](https://miro.medium.com/v2/resize:fit:875/1*n5aJaOcwSFAONUR0D7dJYA.png)

and I will dump the address of the memory and see what the malware will do in this space ,,, the program is writing another shellcode that we will trace again

![](https://miro.medium.com/v2/resize:fit:875/1*KxPizn7lA0zdtYVPKXnaJA.png)

and here is how another transfer execution is done to this shellcode

![](https://miro.medium.com/v2/resize:fit:875/1*DljoQr1o2j6yChTsSUZxNw.png)

we hit another virtualAlloc(), I dump the address allocated by this call

![](https://miro.medium.com/v2/resize:fit:875/1*rgbRuPzlt5-mCm1beiSXgQ.png)

let’s complete the unpacking process

![](https://miro.medium.com/v2/resize:fit:875/1*kRGHO-jFZSO48Ndah02-rg.png)

WOW, we get an MZ Header, and here is the unpacking process ended, the program will transfer the flow to the start of the code section but I will dump this PE File and run it throw the analyzing process(static and dynamic)

![](https://miro.medium.com/v2/resize:fit:875/1*lC4cwx-jwtZNcqYlYWbnAg.png)

so the sample is not packed and this is the real ransomware

![](https://miro.medium.com/v2/resize:fit:875/1*aQvjlfkstporEaTE_mY97Q.png)

I will complete the full analysis in the next part, wait for it

my part 2 about technical analysis

[**Part_2**](https://medium.com/@farghly.mahmod66/death-ransomware-analysis-part-2-ec4bfb1c758f)

thanks for reading……..
